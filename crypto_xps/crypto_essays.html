<!DOCTYPE HTML>
<html>
	<head>
		<meta charset="UTF-8">
		<link rel="stylesheet" href="../style.css">
	</head>
	<body>
		<section>
			<h1>
				Program Description
			</h1>
			<p>
				The exhaustive crypto problem solving program has a set of priorities for the operations that it selects when solving a problem due to design decisions made in the writing of the order two solver. Some sort of order had to be selected, given the nature of the problem. The only alternative to an order would be to randomly assort the order, which has little obvious benefit and adds a lot of
				unnecessary work.
			</p>
			<p>
				The order chosen is particularly interesting because it does not follow the parentheses-exponent-multiplication-division-addition-subtraction scheme laid forth by the popular PEMDAS scheme of operations. Instead the order taken by the author of this order two crypto solver has addition taking first precedence, followed by multiplication, then subtraction, and ending finally with division.
				It is important to note that there is no reason for the order two solver to follow PEMDAS, merely that the arbitrary decision for the order to differ from it was of interest to this program user.
			</p>
			<p>
				Another salient aspect of the order two solution is the way that the operations differ from each other. Addition and multiplication are commutative, meaning that their solution needs only one rule to cover their usage mathematically. Using only one rule though also means that their commutative twin solutions will not get the chance to be used. For instance a problem with the
				numbers (1,2) and a goal of 3 will only ever be solved as (1+2) by this program. Furthermore because subtraction and division are not commutative and therefore require two separate rules in order to completely cover their order two possible solutions. Division also requires ever more work to function properly given that division by zero is undefined by the laws of mathematics. Because of this
				a helper function had to be written to ensure that the number in the denominator is not zero. 
			</p>
			<p>
				The last salient aspect I will discuss is that the nature of the recursion in the crypto solver makes it relatively easy to increase the order of problem that can be solved, provided that every order between the one required and the one currently written is also written. Unfortunately, given my current understanding of Prolog, it does not lend itself to a general solution.
			</p>
		</section>
		<section>
			<h1>
				Nature of the Program
			</h1>
			<p>
				The essential interests of computational cognitive scientists is to study and develop computational heuristics that mimic aspects of human cognition. The goal of this practice is to try and further our understanding of cognition in organisms with brains, not specifically to develop the heuristics which are used in the science as a tool for understanding. This program is not consistent with that goal, where instead of going with the heuristic approach of solving
				the general problem of crypto problems in a human like fashion, it opts for an algorithmic approach that exhaustively solves the problems by going through every possible combination and looking for those that are valid solutions. 
			</p>
			<p>
				That being the case, the exhaustive crypto problem solver is still interesting for other reasons. For instance, from a cognitive scientist perspective, the programming displayed in the exhaustive crypto problem solver can shed some light on how people think when writing the type of program that can solve these problems in a non human way. The ordering of the predicates, the formatting of the code, and even the decisions that went into choosing one arbitrary
				operation to take priority over another all point to aspects of human cognition went into the writing of the program.
			</p>
			<p>
				Another interesting facet that can be gleaned from the exhaustive crypto problem solver lies within the way in which the program uses recursion to solve the problem it sets for the solve. This recursion is somewhat a matter of course given the nature of the programming language that it was written in (Prolog is a language that heavily encourages the use of recursion). But the way in which the program was chosen to recurse is still interesting and suggests a way
				in which we solve the problems in that we also need to go at the problem two numbers at a time, solving them as an initial small crypto problem before going on to solve the larger problem.
			</p>
		</section>
	</body>
</html>
